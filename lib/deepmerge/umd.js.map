{"version":3,"sources":["umd.js"],"names":["global","factory","exports","module","define","amd","self","deepmerge","this","isMergeableObject","value","stringValue","Object","prototype","toString","call","$$typeof","REACT_ELEMENT_TYPE","isReactElement","Symbol","for","cloneUnlessOtherwiseSpecified","options","clone","val","Array","isArray","defaultArrayMerge","target","source","concat","map","element","getKeys","keys","getOwnPropertySymbols","filter","symbol","propertyIsEnumerable","propertyIsOnObject","object","property","_","mergeObject","destination","forEach","key","hasOwnProperty","customMerge","getMergeFunction","arrayMerge","sourceIsArray","all","array","Error","reduce","prev","next"],"mappings":"CAAC,SAAUA,EAAQC,GACC,iBAAZC,SAA0C,oBAAXC,OAAyBA,OAAOD,QAAUD,IAC9D,mBAAXG,QAAyBA,OAAOC,IAAMD,OAAOH,IACnDD,EAASA,GAAUM,MAAaC,UAAYN,IAH9C,CAIEO,KAAM,WAAc,aAErB,IAAIC,EAAoB,SAA2BC,GAClD,UAIwBA,EAJDA,IAKY,iBAAVA,IAGPA,EAPHA,EAUQ,qBAFnBC,EAAcC,OAAOC,UAAUC,SAASC,KAAKL,KAG7B,kBAAhBC,GAQL,SAAwBD,GACvB,OAAOA,EAAMM,WAAaC,EARtBC,CAAeR,KALpB,IAAmBA,EACdC,EALoBD,GAazB,IACIO,EADiC,mBAAXE,QAAyBA,OAAOC,IAClBD,OAAOC,IAAI,iBAAmB,MAUtE,SAASC,EAA8BX,EAAOY,GAC7C,OAA0B,IAAlBA,EAAQC,OAAmBD,EAAQb,kBAAkBC,GAC1DH,GANiBiB,EAMKd,EALlBe,MAAMC,QAAQF,GAAO,GAAK,IAKAd,EAAOY,GACrCZ,EAPJ,IAAqBc,EAUrB,SAASG,EAAkBC,EAAQC,EAAQP,GAC1C,OAAOM,EAAOE,OAAOD,GAAQE,IAAI,SAASC,GACzC,OAAOX,EAA8BW,EAASV,KAoBhD,SAASW,EAAQL,GAChB,OAAOhB,OAAOsB,KAAKN,GAAQE,QATaF,EAS0BA,EAR3DhB,OAAOuB,sBACXvB,OAAOuB,sBAAsBP,GAAQQ,OAAO,SAASC,GACtD,OAAOT,EAAOU,qBAAqBD,KAElC,KALJ,IAAyCT,EAYzC,SAASW,EAAmBC,EAAQC,GACnC,IACC,OAAOA,KAAYD,EAClB,MAAME,GACP,OAAO,GAWT,SAASC,EAAYf,EAAQC,EAAQP,GACpC,IAAIsB,EAAc,GAiBlB,OAhBItB,EAAQb,kBAAkBmB,IAC7BK,EAAQL,GAAQiB,QAAQ,SAASC,GAChCF,EAAYE,GAAOzB,EAA8BO,EAAOkB,GAAMxB,KAGhEW,EAAQJ,GAAQgB,QAAQ,SAASC,GAblC,IAA0BlB,EAAQkB,IAC1BP,EADkBX,EAcHA,EAdWkB,EAcHA,IAZxBlC,OAAOmC,eAAehC,KAAKa,EAAQkB,IACpClC,OAAO0B,qBAAqBvB,KAAKa,EAAQkB,MAezCP,EAAmBX,EAAQkB,IAAQxB,EAAQb,kBAAkBoB,EAAOiB,IACvEF,EAAYE,GAhDf,SAA0BA,EAAKxB,GAC9B,IAAKA,EAAQ0B,YACZ,OAAOzC,EAER,IAAIyC,EAAc1B,EAAQ0B,YAAYF,GACtC,MAA8B,mBAAhBE,EAA6BA,EAAczC,EA2CpC0C,CAAiBH,EAAKxB,EAAtB2B,CAA+BrB,EAAOkB,GAAMjB,EAAOiB,GAAMxB,GAE5EsB,EAAYE,GAAOzB,EAA8BQ,EAAOiB,GAAMxB,MAGzDsB,EAGR,SAASrC,EAAUqB,EAAQC,EAAQP,IAClCA,EAAUA,GAAW,IACb4B,WAAa5B,EAAQ4B,YAAcvB,EAC3CL,EAAQb,kBAAoBa,EAAQb,mBAAqBA,EAGzDa,EAAQD,8BAAgCA,EAExC,IAAI8B,EAAgB1B,MAAMC,QAAQG,GAIlC,OAFgCsB,IADZ1B,MAAMC,QAAQE,GAKvBuB,EACH7B,EAAQ4B,WAAWtB,EAAQC,EAAQP,GAEnCqB,EAAYf,EAAQC,EAAQP,GAJ5BD,EAA8BQ,EAAQP,GAoB/C,OAZAf,EAAU6C,IAAM,SAAsBC,EAAO/B,GAC5C,IAAKG,MAAMC,QAAQ2B,GAClB,MAAM,IAAIC,MAAM,qCAGjB,OAAOD,EAAME,OAAO,SAASC,EAAMC,GAClC,OAAOlD,EAAUiD,EAAMC,EAAMnC,IAC3B,KAGcf","file":"umd.js","sourcesContent":["(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n\ttypeof define === 'function' && define.amd ? define(factory) :\n\t(global = global || self, global.deepmerge = factory());\n}(this, function () { 'use strict';\n\n\tvar isMergeableObject = function isMergeableObject(value) {\n\t\treturn isNonNullObject(value)\n\t\t\t&& !isSpecial(value)\n\t};\n\n\tfunction isNonNullObject(value) {\n\t\treturn !!value && typeof value === 'object'\n\t}\n\n\tfunction isSpecial(value) {\n\t\tvar stringValue = Object.prototype.toString.call(value);\n\n\t\treturn stringValue === '[object RegExp]'\n\t\t\t|| stringValue === '[object Date]'\n\t\t\t|| isReactElement(value)\n\t}\n\n\t// see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25\n\tvar canUseSymbol = typeof Symbol === 'function' && Symbol.for;\n\tvar REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for('react.element') : 0xeac7;\n\n\tfunction isReactElement(value) {\n\t\treturn value.$$typeof === REACT_ELEMENT_TYPE\n\t}\n\n\tfunction emptyTarget(val) {\n\t\treturn Array.isArray(val) ? [] : {}\n\t}\n\n\tfunction cloneUnlessOtherwiseSpecified(value, options) {\n\t\treturn (options.clone !== false && options.isMergeableObject(value))\n\t\t\t? deepmerge(emptyTarget(value), value, options)\n\t\t\t: value\n\t}\n\n\tfunction defaultArrayMerge(target, source, options) {\n\t\treturn target.concat(source).map(function(element) {\n\t\t\treturn cloneUnlessOtherwiseSpecified(element, options)\n\t\t})\n\t}\n\n\tfunction getMergeFunction(key, options) {\n\t\tif (!options.customMerge) {\n\t\t\treturn deepmerge\n\t\t}\n\t\tvar customMerge = options.customMerge(key);\n\t\treturn typeof customMerge === 'function' ? customMerge : deepmerge\n\t}\n\n\tfunction getEnumerableOwnPropertySymbols(target) {\n\t\treturn Object.getOwnPropertySymbols\n\t\t\t? Object.getOwnPropertySymbols(target).filter(function(symbol) {\n\t\t\t\treturn target.propertyIsEnumerable(symbol)\n\t\t\t})\n\t\t\t: []\n\t}\n\n\tfunction getKeys(target) {\n\t\treturn Object.keys(target).concat(getEnumerableOwnPropertySymbols(target))\n\t}\n\n\tfunction propertyIsOnObject(object, property) {\n\t\ttry {\n\t\t\treturn property in object\n\t\t} catch(_) {\n\t\t\treturn false\n\t\t}\n\t}\n\n\t// Protects from prototype poisoning and unexpected merging up the prototype chain.\n\tfunction propertyIsUnsafe(target, key) {\n\t\treturn propertyIsOnObject(target, key) // Properties are safe to merge if they don't exist in the target yet,\n\t\t\t&& !(Object.hasOwnProperty.call(target, key) // unsafe if they exist up the prototype chain,\n\t\t\t\t&& Object.propertyIsEnumerable.call(target, key)) // and also unsafe if they're nonenumerable.\n\t}\n\n\tfunction mergeObject(target, source, options) {\n\t\tvar destination = {};\n\t\tif (options.isMergeableObject(target)) {\n\t\t\tgetKeys(target).forEach(function(key) {\n\t\t\t\tdestination[key] = cloneUnlessOtherwiseSpecified(target[key], options);\n\t\t\t});\n\t\t}\n\t\tgetKeys(source).forEach(function(key) {\n\t\t\tif (propertyIsUnsafe(target, key)) {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {\n\t\t\t\tdestination[key] = getMergeFunction(key, options)(target[key], source[key], options);\n\t\t\t} else {\n\t\t\t\tdestination[key] = cloneUnlessOtherwiseSpecified(source[key], options);\n\t\t\t}\n\t\t});\n\t\treturn destination\n\t}\n\n\tfunction deepmerge(target, source, options) {\n\t\toptions = options || {};\n\t\toptions.arrayMerge = options.arrayMerge || defaultArrayMerge;\n\t\toptions.isMergeableObject = options.isMergeableObject || isMergeableObject;\n\t\t// cloneUnlessOtherwiseSpecified is added to `options` so that custom arrayMerge()\n\t\t// implementations can use it. The caller may not replace it.\n\t\toptions.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;\n\n\t\tvar sourceIsArray = Array.isArray(source);\n\t\tvar targetIsArray = Array.isArray(target);\n\t\tvar sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;\n\n\t\tif (!sourceAndTargetTypesMatch) {\n\t\t\treturn cloneUnlessOtherwiseSpecified(source, options)\n\t\t} else if (sourceIsArray) {\n\t\t\treturn options.arrayMerge(target, source, options)\n\t\t} else {\n\t\t\treturn mergeObject(target, source, options)\n\t\t}\n\t}\n\n\tdeepmerge.all = function deepmergeAll(array, options) {\n\t\tif (!Array.isArray(array)) {\n\t\t\tthrow new Error('first argument should be an array')\n\t\t}\n\n\t\treturn array.reduce(function(prev, next) {\n\t\t\treturn deepmerge(prev, next, options)\n\t\t}, {})\n\t};\n\n\tvar deepmerge_1 = deepmerge;\n\n\treturn deepmerge_1;\n\n}));\n"]}